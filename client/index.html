<!doctype html>
<html>
<head>
    <meta charset="UTF-8" />
    <title>Carmageddon</title>
    <script src="/phaser.min.js"></script>
    <script src="http://localhost:8000/socket.io/socket.io.js"></script>
</head>
<body>

<script type="text/javascript">
    var head = document.getElementsByTagName('head')[0];
    var script = document.createElement('script');
    script.type = 'text/javascript';
    script.src = 'http://'+location.hostname+':8000/socket.io/socket.io.js';
    head.appendChild(script);

    window.onload = function() {

        //Constants
        var tileWidth = 75;
        var tileHeight = 57;
        var mapHeight = 16;
        var mapWidth = 16;

        //frame id's for reference
        var grassFrame = 65;
        var fountainFrame = 209;

        //actual frame numbers for hazards
        var waterHazard = 192;
        var potholeHazard = 193;
        var gravelHazard = 208;

        var steelIndexes = [2,3,18,19,34,35,36,50,51,52,66,67,68,82,83,98,99,114,115,130,131,132,146,147,148,162,163,164, 178,179,180];
        var woodIndexes = [5,6,21,22,37,38,39,53,54,55,69,70,71,85,86,101,102,117,118,133,134,135,149,150,151,165,166,167,181,182,183];
        var brickIndexes = [8,9,24,25,40,41,42,56,57,58,67,68,72,73,74,88,89,104,105,120,121,136,137,138,152,153,154,168,169,170,184,185,186];
        var otherNonDrivable = [grassFrame, fountainFrame];

        var buildingIndexes = steelIndexes.concat(woodIndexes).concat(brickIndexes);
        var blockingIndexes = buildingIndexes.concat(otherNonDrivable);

        //Tweakable Constants
        var sound = false;

        var waterTime = 3;
        var waterImmunityTime = 5;

        var potholeTime = 3;
        var potholeImmunityTime = 5;

        var gravelTime = 3;
        var gravelImmunityTime = 5;

        //  States
        var socket;
        var myCar;
        var otherCar;

        var myCarSprite;
        var otherCarSprite;
        var splashMusic;
        var gameMusic;

        var hazardsMap =  new Array(256);
        var tileCollisionGroup;

        //initialize array as 0.
        for (var i=0;i<256;i++) {
            hazardsMap[i] = 0;
        }

        insertHazard(2,0,waterHazard);
        insertHazard(6,3,potholeHazard);
        insertHazard(1,7,gravelHazard);

        function insertHazard(x,y,hazard) {
            hazardsMap[x+y*mapWidth] = hazard;
        }

        var map1 = [97, 161, 161, 130, 161, 161, 130, 161, 161, 162, 66, 66, 66, 66, 66, 66, 146, 3, 4, 146, 6, 7, 146, 9, 10, 146, 66, 66, 66, 66, 66, 66, 146, 19, 20, 146, 22, 23, 146, 25, 26, 146, 66, 66, 66, 66, 66, 66, 178, 161, 161, 98, 130, 161, 98, 161, 130, 98, 161, 161, 162, 66, 66, 66, 146, 35, 36, 37, 146, 38, 39, 40, 146, 41, 42, 43, 146, 66, 66, 66, 146, 51, 52, 53, 146, 54, 55, 56, 146, 57, 58, 59, 178, 161, 162, 66, 146, 67, 68, 69, 146, 70, 71, 72, 146, 73, 74, 75, 146, 66, 146, 66, 178, 161, 161, 130, 98, 161, 130, 161, 98, 130, 161, 161, 177, 66, 146, 66, 146, 83, 84, 146, 86, 87, 146, 89, 90, 146, 66, 66, 66, 97, 98, 162, 146, 99, 100, 146, 102, 103, 146, 105, 106, 146, 66, 66, 66, 146, 210, 146, 146, 115, 116, 146, 118, 119, 146, 121, 122, 146, 66, 66, 66, 129, 161, 177, 178, 161, 161, 98, 130, 161, 98, 161, 130, 98, 161, 161, 162, 66, 66, 66, 146, 131, 132, 133, 146, 134, 135, 136, 146, 137, 138, 139, 146, 66, 66, 66, 146, 147, 148, 149, 146, 150, 151, 152, 146, 153, 154, 155, 146, 66, 66, 66, 146, 163, 164, 165, 146, 166, 167, 168, 146, 169, 170, 171, 146, 66, 66, 66, 146, 179, 180, 181, 146, 182, 183, 184, 146, 185, 186, 187, 146, 66, 66, 66];

        var currentSpeed = 0;

        /**************************************************
         ** GAME PLAYER CLASS
         **************************************************/
        var Player = function(xPos, yPos, rotationStart, frame) {
            var id;
            var car;
            var x = xPos;
            var y = yPos;
            var rotation = rotationStart;
            var frame = frame;
            var water = false;
            var waterImmunity = false;
            var pothole = false;
            var potholeImmunity = false;
            var gravel = false;
            var gravelImmunity = false;

            // Define which variables and methods can be accessed
            return {
                id: id,
                car: car,
                x: x,
                y: y,
                rotation: rotation,
                frame: frame,
                water: water,
                waterImmunity: waterImmunity,
                pothole: pothole,
                potholeImmunity: potholeImmunity,
                gravel: gravel,
                gravelImmunity: gravelImmunity
            }
        };

        function calculateCarPos(car) {
            var x = parseInt(car.x/75);
            var y = parseInt(car.y/57);

            return (x+y*mapWidth);
        }

        //hazard functions
        function clearWater() {
            myCar.water = false;
        }

        function clearWaterImmunity() {
            myCar.waterImmunity = false;
        }

        function clearPothole() {
            myCar.pothole = false;
        }

        function clearPotholeImmunity() {
            myCar.potholeImmunity = false;
        }

        function clearGravel() {
            myCar.gravel = false;
        }

        function clearGravelImmunity() {
            myCar.gravelImmunity = false;
        }

        var boot = function(game) {}

        boot.prototype = {
            preload: function() {
                this.game.load.image("splash","splash-screen.jpg");
                this.game.load.image("redCar","redCar.png");
                this.game.load.image("orangeCar","orangeCar.png");
                this.game.load.spritesheet('gameSprites', 'Sprites.png', 75, 57);
                this.game.load.audio('splashMusic', 'AbstractBeat.wav');
                this.game.load.audio('gameMusic', 'DNB1_130.wav');
            },
            create: function() {
                socket = io.connect("http://"+location.hostname+":8000", {transports: ["websocket"]});

                // Socket connection successful
                socket.on("connect", function(){
                    console.log("Connected to socket server");
                });

                // Socket disconnection
                socket.on("disconnect", function() {
                    console.log("Disconnected from socket server");
                });

                socket.on("starting info", function(data) {
                    myCar = new Player(data.x, data.y, data.rotation, data.frame);
                    myCar.id = data.id;
                });

                // New player message received
                socket.on("new player", function(data) {
                    otherCar = new Player(data.x, data.y, data.rotation, data.frame);
                    otherCar.id = data.id;

                    game.state.start("TheGame");
                });

                socket.on("move player", function(data) {
                    // Update player position
                    otherCarSprite.x = data.x;
                    otherCarSprite.y = data.y;
                    otherCarSprite.rotation = data.rotation;
                });

                this.game.state.start("Splash");
            }
        }

        var splash = function(game) {}

        splash.prototype = {
            create: function() {
                var splashImage = this.game.add.button(game.world.centerX, game.world.centerY, "splash",this.connect,this);
                splashImage.anchor.setTo(0.5, 0.5);

                splashMusic = this.game.add.audio('splashMusic');
                splashMusic.volume = 0.8;
                splashMusic.loop = true;
                if (sound) {
                    splashMusic.play();
                }
            },
            connect: function() {
                splashMusic.loop = false;
                splashMusic.stop();

                this.game.state.start("WaitingToConnect");
            }
        }

        var waitingToConnect = function(game) {}

        waitingToConnect.prototype = {
            create: function() {
                var text = game.add.text(game.world.centerX, game.world.centerY, "Waiting for game to start", { font: "65px Arial", fill: "#ffffff", align: "center" });
                text.anchor.set(0.5);

                socket.emit("new player",{});
            }
        }

        var theGame = function(game) {}

        theGame.prototype = {
            create: function() {
                //draw background first so they are lowest
                for (var y=0; y<mapHeight; y++) {
                    for (var x = 0; x < mapWidth; x++) {
                        var grassTile = tile = game.add.sprite(x*tileWidth,y*tileHeight,'gameSprites');
                        grassTile.frame = grassFrame;
                    }
                }

                //initialize building group
                tileCollisionGroup = game.add.physicsGroup();
                tileCollisionGroup.enableBody = true;

                for (var y=0; y<mapHeight; y++) {
                    for (var x=0; x<mapWidth; x++) {
                        var frame = map1[x+y*mapWidth]-1;//minus 1 since tool increases indexes by 1

                        var tile = game.add.sprite(x*tileWidth,y*tileHeight,'gameSprites');
                        tile.frame = frame;

                        if (blockingIndexes.indexOf(frame)>=0) {
                            //alert("x:"+x+ " y:"+y+ " frame:"+frame);
                            tileCollisionGroup.add(tile);
                        }

                        //insert hazard if appropriate
                        if (hazardsMap[x+y*mapWidth]>0) {
                            //ok - draw in hazard here
                            var hazardTile = game.add.sprite(x*tileWidth,y*tileHeight,'gameSprites');
                            hazardTile.frame = hazardsMap[x+y*mapWidth];
                        }
                    }
                }

                game.physics.arcade.enable(tileCollisionGroup);

                tileCollisionGroup.setAll('body.collideWorldBounds', true);
                tileCollisionGroup.setAll('body.immovable', true);
                tileCollisionGroup.setAll('body.moves', false);

                //my car
                //myCarSprite = game.add.sprite(myCar.x,myCar.y, 'gameSprites');
                //myCarSprite.frame = myCar.frame;
                myCarSprite = game.add.sprite(game.world.centerX,game.world.centerY, 'redCar');

                myCarSprite.anchor.setTo(0.5, 0.5);

                myCarSprite.x = myCar.x;
                myCarSprite.y = myCar.y;

                game.physics.enable(myCarSprite, Phaser.Physics.ARCADE);
                myCarSprite.enableBody = true;
                myCarSprite.body.maxVelocity.setTo(400,400);
                myCarSprite.body.collideWorldBounds = true;

                myCarSprite.body.setSize(52,26);

                //otherCar
                //otherCarSprite = game.add.sprite(otherCar.x,otherCar.y, 'gameSprites');
                //otherCarSprite.frame = otherCar.frame;
                otherCarSprite = game.add.sprite(game.world.centerX,game.world.centerY, 'orangeCar');

                otherCarSprite.anchor.setTo(0.5, 0.5);

                otherCarSprite.x = otherCar.x;
                otherCarSprite.y = otherCar.y;

                game.physics.enable(otherCarSprite, Phaser.Physics.ARCADE);
                myCarSprite.enableBody = true;
                otherCarSprite.body.maxVelocity.setTo(400,400);
                otherCarSprite.body.collideWorldBounds = true;
                //OK - only other client should move its car or they will be out of sync - if we want to allow pushing - need to send message
                //to other client
                otherCarSprite.body.immovable = true;

                otherCarSprite.body.setSize(52,26);

                cursors = game.input.keyboard.createCursorKeys();

                gameMusic = this.game.add.audio('gameMusic');
                gameMusic.volume = 0.8;
                gameMusic.loop = true;
                if (sound) {
                    gameMusic.play();
                }

                //gameMusic.loop = false;
                //gameMusic.stop();

            },
            update: function() {
                game.physics.arcade.collide(myCarSprite, tileCollisionGroup);
                game.physics.arcade.collide(myCarSprite, otherCarSprite);

                var carTurned = false;

                if (cursors.left.isDown)
                {
                    myCarSprite.angle -= 4;
                    carTurned = true;
                }
                else if (cursors.right.isDown)
                {
                    myCarSprite.angle += 4;
                    carTurned = true;
                }

                else if (cursors.up.isDown)
                {
                    if (!myCar.pothole) {
                        //  The speed we will travel at
                        currentSpeed = 300;
                    }
                }
                else if (cursors.down.isDown)
                {
                    if (!myCar.pothole) {
                        //  The speed we will travel at
                        currentSpeed = -160;
                    }
                }
                else {
                    if (currentSpeed != 0) {
                        currentSpeed = currentSpeed/1.2;
                    }
                }

                if (myCar.gravel) {
                    currentSpeed = currentSpeed/2;
                }

                if (myCar.water) {
                    myCarSprite.angle += 10;
                }

                if (hazardsMap[calculateCarPos(myCarSprite)]) {
                    var hazard = hazardsMap[calculateCarPos(myCarSprite)];

                    if (hazard == waterHazard && myCar.waterImmunity == false) {
                        myCar.water = true;
                        myCar.waterImmunity = true;

                        game.time.events.add(Phaser.Timer.SECOND*waterTime, clearWater, this);
                        game.time.events.add(Phaser.Timer.SECOND*waterImmunityTime, clearWaterImmunity, this);
                    }

                    if (hazard == potholeHazard && myCar.potholeImmunity == false) {
                        currentSpeed = 0;
                        myCar.pothole = true;
                        myCar.potholeImmunity = true;

                        game.time.events.add(Phaser.Timer.SECOND*potholeTime, clearPothole, this);
                        game.time.events.add(Phaser.Timer.SECOND*potholeImmunityTime, clearPotholeImmunity, this);
                    }

                    if (hazard == gravelHazard && myCar.gravelImmunity == false) {
                        myCar.gravel = true;
                        myCar.gravelImmunity = true;

                        game.time.events.add(Phaser.Timer.SECOND*gravelTime, clearGravel, this);
                        game.time.events.add(Phaser.Timer.SECOND*gravelImmunityTime, clearGravelImmunity, this);
                    }
                }

                game.physics.arcade.velocityFromRotation(myCarSprite.rotation, currentSpeed, myCarSprite.body.velocity);

                if (currentSpeed != 0 || carTurned) {
                    socket.emit("move player", {x: myCarSprite.x, y: myCarSprite.y, rotation: myCarSprite.rotation});
                }
            }
        }

        var game = new Phaser.Game(1200, 912, Phaser.AUTO, 'game');

        game.state.add("Boot", boot);
        game.state.add("Splash",splash);
        game.state.add("WaitingToConnect",waitingToConnect);
        game.state.add("TheGame",theGame);
//        game.state.add("GameOver",gameOver);
        game.state.start("Boot");

    };

</script>

</body>
</html>